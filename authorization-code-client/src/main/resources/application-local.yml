server:
  port: 8081
  servlet:
    session:
      # если хранить авторизованных клиентов (OAuth2AuthorizedClients) в сессии,
      # а время Expire токена установить больше времени сессии, то при протухании токена
      # из сессии будет браться объект Authentication с isAuthenticated=true, все фильтры его пропустят,
      # и в запросее на Resource-Server в хидере Authorization будет заэкспаренный токен. Поэтому надо
      # добавить проверку на expire в фильтры. Здесь сделан простой workaround - время сессии меньше времени жизни
      # токена. Но так лделать не надо
      timeout: 60s

host: 'localhost'

# This is keycloak from docker-compose.yml
keycloak:
  uri: 'https://${host}:8443'
  realm: "alfa-skillbox-keycloak"
spring:
  security:
    oauth2:
      client:
        provider:
          keycloak:
            issuer-uri: '${keycloak.uri}/auth/realms/${keycloak.realm}'
            # 1. после вызова http://адрес_клиента/oauth2/authorization/{registrationId} инициализируется процесс OAuth2.0
            # клиент формирует uri_auth = ${authorization-uri}?response_type=code&client_id=${client-id}&scope=${scope}&state=redirect_uri=${redirect-uri}
            # и отправляет 302 ответ с Location=uri_auth, чтобы кейкллок начал процесс авторизации пользователя, и вернул
            # через редирект 302 ответ с Location=redirect_uri?code=&state= на клиента
            authorization-uri: '${keycloak.uri}/auth/realms/${keycloak.realm}/protocol/openid-connect/auth'
            # 2. Клиент, получая code и state, подставляет их в POST запрос на ${token-uri} и в ответ получает access_token, refresh_token, id_token
            token-uri: '${keycloak.uri}/auth/realms/${keycloak.realm}/protocol/openid-connect/token'
            # 3. После получения токенов клиент уже авторизованно обращается на ${userinfoUri} для получения информации о пользователе
            userinfoUri: "${keycloak.uri}/auth/realms/${keycloak.realm}/protocol/openid-connect/userinfo"
            user-name-attribute: 'preferred_username'
            end_session_endpoint: '${ukeycloak.uri}/auth/realms/${keycloak.realm}/protocol/openid-connect/logout'
            logout-url: '${keycloak.uri}/auth/realms/${keycloak.realm}/protocol/openid-connect/logout'
            logout-redirect-url: 'http://${host}:${server.port}/login'
        registration:
          ac-client:
            registrationId: 'ac-client'
            provider: 'keycloak'
            client-id: 'authorization-code-client'
            client-secret: 'auth-code-secret'
            authorization-grant-type: 'authorization_code'
            # важно указать openid в scope, если необходимо в Spring запустить процесс по протоколу openid-connect
            scope: 'openid,resource-server-scope'
            redirect-uri: 'http://${host}:${server.port}/login/oauth2/code/keycloak'

logging:
  level:
    org.springframework: debug

management:
  endpoints:
    loggers:
      enabled: true
    web:
      exposure:
        include: loggers, health